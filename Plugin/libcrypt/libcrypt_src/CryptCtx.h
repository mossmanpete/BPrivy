#ifndef _H_CRYPT_CTX_
#define _H_CRYPT_CTX_

#include <string>
#include <cstdint>
#include <unordered_map>
#include <openssl/evp.h>
#include "CryptUtils.h"
#include "CryptInfo.h"

namespace crypt
{
	using std::wstring;

	/*****************************************************************/
	/*************************** CryptCtx ****************************/
	/*****************************************************************/
	class CryptCtx
	{
	public:
		typedef std::wstring ucs;
		static CipherEnum			CipherStrToEnum		(const wstring& cipher);
		/**
		*	Creates and stores a crypt-ctx against the supplied handle. The k parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param handle. A Unicode string (UCS16 for Windows and UCS32 for Mac/Unix/Linux).
		*		 A empty string is not allowed while creating a handle hence no context
		*        can exist against a empty string handle. However, a empty-string can be
		*	     passed into the GetP/Exists routines with the result that no crypt-context
		*        will be found. This technique is used to pass a empty-handle to routines that
		*        optionally require a valid crypt-handle. This will affect a bypass of the
		*        encryption/decryption layer in various BPrivyAPI routines that have been written
		*        to bypass the encryption layer of CryptCtx::GetP returned NULL. For e.g.
		*        BPrivyAPI::zeroFile uses this technique
		*        to indicate to BPrivyAPI::overwriteFile that the data in the zero-buffer
		*        should not be encrypted before writing to file.
		* @param k. passwd. Gets zeroe'd out if the call is successful.
		* @param cipher. The cipher to use for en/decryption.
		* @param key_len. The length of the key to be generated for en/decryption.
		*/
		static const CryptCtx*		Create				(const ucs& handle,
														 Buf<char>& k,
														 CipherEnum cipher = CIPHER_BF_CBC,
														 unsigned int key_len = DEFAULT_KEY_LEN);
		/**
		*	Creates and stores a crypt-ctx and returns its handle. This handle should
		*	be returned to Javascript for use later with the API. The k parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param k. passwd. Gets zeroe'd out if the call is successful.
		* @param cryptInfo. cryptInfo bytes read from an encrypted AB. Should've been
		*	generated by serializeInfo().
		*/
		static void					Load				(const ucs& handle,
														 Buf<char>& k,
														 const Buf<uint8_t>& cryptInfo);
		/** If handle is an empty string, a NULL value is returned. See documentation for Create. */
		static const CryptCtx*		GetP				(const ucs& handle);
		/** If handle is an empty string, a false value is returned. See documentation for Create. */
		static bool					Exists				(const ucs& handle);
		static void					Destroy				(const ucs& handle);

		const CryptInfo&			GetInfo				() const {return m_info;}
		void						serializeInfo		(BufHeap<uint8_t>& outBuf) const;
		void						Encrypt				(const Buf<uint8_t>& in,
														 ByteBuf& out) const;
		void						Decrypt				(ByteBuf&& in, ByteBuf& out) const;
		bool						operator==			(const CryptCtx& other) const 
			{ return m_randKey == other.m_randKey; }

	protected:
									CryptCtx			(CipherEnum cipher,
														 unsigned int keyLen);
									CryptCtx			(const Buf<uint8_t>& cryptInfo);
		virtual						~CryptCtx			() {zero();}
		virtual void				zero				();

	private:
									CryptCtx			(const CryptCtx&);// not to be defined
		CryptCtx&					operator=			(const CryptCtx&);// not to be defined
		//static unsigned int			MakeHandle			() {return ++s_lastHandle;}
		void						EncryptImpl			(const Buf<uint8_t>& in,
														 ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		void						DecryptImpl			(ByteBuf&& in,
														 ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		size_t						DecryptOne			(CipherBlob& in, ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		//typedef std::unordered_map<unsigned int, CryptCtx*> map;
		typedef std::unordered_map<ucs, CryptCtx*> map;
		static map					s_ctxMap;
		//static unsigned int			s_lastHandle;

		/** Object variables */
		Array<uint8_t, SCRYPT_DK_SIZE> m_dk;
		ByteBuf						m_randKey;
		CryptInfo					m_info;
	};

	inline void
	CryptCtx::Decrypt(ByteBuf&& in, ByteBuf& out) const
	{
		DecryptImpl(std::forward<ByteBuf>(in), out, m_randKey);
	}

	inline void
	CryptCtx::Encrypt(const Buf<uint8_t>& in, ByteBuf& out) const
	{
		EncryptImpl(in, out, m_randKey);
	}

	inline CipherEnum
	CryptCtx::CipherStrToEnum(const wstring& cipher)
	{
		if (cipher == L"CIPHER_AES_CBC") {
			return CIPHER_AES_CBC;
		}
		else // || if (cipher == L"CIPHER_BF_CBC")
		{
			return CIPHER_BF_CBC;
		}
	};
}
#endif // !_H_CRYPT_CTX_