#ifndef _H_CRYPT_CTX_
#define _H_CRYPT_CTX_

#include <string>
#include <cstdint>
#include <unordered_map>
#include <openssl/evp.h>
#include "Utils.h"
#include <libscrypt.h>
#include <openssl/evp.h>

namespace crypt
{
	using std::wstring;

	/** Call this to initialize the library once. Initializes openssl. */
	void	initLibcrypt	();
	void	unloadLibcrypt	();

	struct Error
	{
		Error(const wstring& c) : code(c), errc(0) {}
		Error(unsigned int c) : code(CODE_OS_ERROR), errc(c) {}
		Error(const wstring& c, const wstring& msg) : code(c), msg(msg), errc(0) {}
		Error(const wstring& c, const std::string& msg) 
			: code(c), msg(LocaleToUnicode(msg)), errc(0) {}

		wstring code;
		wstring msg;
		unsigned int errc;

		static wstring LocaleToUnicode(const std::string& str);
		static void		ThrowOpensslError();

		// Error Codes
		static const wstring	CODE_BAD_PARAM;
		static const wstring	CODE_NO_MEM;
		static const wstring	CODE_OS_ERROR;
		static const wstring	CODE_CRYPTO_ERROR;
		static const wstring	CODE_INTERNAL_ERROR;
		static const wstring	CODE_NO_CSP;
	};

	typedef enum {
		/** 
		* THESE NUMBERS CAN NEVER CHANGE BECAUSE
		* THEY ARE BURNT INTO DB FILES ON DISK.
		*/
		BF_CBC = 1, // Blowfish in CBC mode
		AES_CBC= 2  // AES (Rijndael) in CBC mode
	} CipherEnum;

	typedef enum {
		DEFAULT_KEY_LEN = 32 // Key Length in #bytes
	} CRYPT_CONSTANT;

	/** Fixed Cipher related params required by openssl */
	class CipherParams
	{
	public:
		/*IV_LEN_BF = 8, //IV length in #bytes
		IV_LEN_AES= 16,
		BLK_SZ_BF = 8, //block size in #bytes
		BLK_SZ_AES= 16,*/
		// iv should be the size of the block. Hence it depends
		// on cipher block size. AES has 16 bytes and BF has 8 bytes.
							CipherParams	(CipherEnum);
	};

	struct CryptInfo
	{
		typedef enum {
			LOGN = 15,
			R = 8,
			P = 1,
			LOGN_SIZE = 1,
			R_SIZE = 4,
			P_SIZE = 4,
			CIPHER_SIZE = 1,
			KEYLEN_SIZE = 1,
			SALT_SIZE = SCRYPT_SALT_SIZE,
			SIG_SIZE = 32,
			BUF_SIZE = (LOGN_SIZE+
						R_SIZE+
						P_SIZE+
						CIPHER_SIZE+
						KEYLEN_SIZE+
						SALT_SIZE+SIG_SIZE)
		} CONSTANT;

		/** Following are persisted to disk */
		uint8_t		m_logN;
		uint32_t	m_r;
		uint32_t	m_p;
		uint8_t		m_cipher; // Cipher Enum
		uint8_t		m_keyLen; // Key Length in #bytes.
		Array<uint8_t, SCRYPT_SALT_SIZE> m_salt;
		Array<uint8_t, SIG_SIZE> m_signature;

		/** Following are ephemeral */
		const EVP_CIPHER*	m_EVP_CIPHER;
		uint8_t 			m_ivLen;  // IV size in #bytes
		uint8_t				m_blkSize;// cipher's block size in #bytes

					CryptInfo		(uint8_t cipher, uint16_t keyLen);
					CryptInfo		(const std::string& cryptInfo);
					~CryptInfo		() {zero();}
		void		zero			();
		bool		Marshall		(std::string& cryptInfo);
		void		Verify			() const;
		void		Sign			();

	private:
					CryptInfo		(const CryptInfo&);// not to be defined
		CryptInfo&	operator=		(const CryptInfo&);// not to be defined
		void		Unmarshall		(const std::string&);
		void		ConstructCommon	(CipherEnum);
	};

	class CryptCtx
	{
	public:
		static CipherEnum			CipherStrToEnum		(const wstring& cipher);
		/**
		*	Creates and stores a crypt-ctx and returns its handle. This handle should
		*	be returned to Javascript for use later with the API. The $ parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param $. passwd. Gets zeroe'd out if the call is successful.
		* @param cipher. The cipher to use for en/decryption.
		* @param key_len. The length of the key to be generated for en/decryption.
		*/
		static unsigned	int			Make				(Buf<wchar_t>& $,
														 CipherEnum cipher = BF_CBC,
														 unsigned int key_len = DEFAULT_KEY_LEN);
		/**
		*	Creates and stores a crypt-ctx and returns its handle. This handle should
		*	be returned to Javascript for use later with the API. The $ parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param $. passwd. Gets zeroe'd out if the call is successful.
		* @param cryptInfo. cryptInfo bytes read from an encrypted DB. Should've been
		*	generated by GetInfo().Marshall().
		*/
		static unsigned int			Make				(Buf<wchar_t>& $,
														 std::string& cryptInfo);
		static const CryptCtx&		Get					(unsigned int handle);
		static void					Destroy				(unsigned int handle);
		const CryptInfo&			GetInfo				() const {return m_info;}
		void						Encrypt				(const std::string& in,
														 std::string& out);
		void						Decrypt				(const std::string& in,
														 std::string& out);

	protected:
									CryptCtx			(CipherEnum cipher,
														 unsigned int keyLen);
									CryptCtx			(const std::string& cryptInfo);
		virtual						~CryptCtx			() {zero();}
		virtual void				zero				();

	private:
									CryptCtx			(const CryptCtx&);// not to be defined
		CryptCtx&					operator=			(const CryptCtx&);// not to be defined
		static unsigned int			MakeHandle			() {return ++s_lastHandle;}
		typedef std::unordered_map<unsigned int, CryptCtx*> map;
		static map					s_ctxMap;
		static unsigned int			s_lastHandle;

		Array<uint8_t, SCRYPT_DK_SIZE> m_dk;
		const CryptInfo				m_info;
	};

	inline CipherEnum
	CryptCtx::CipherStrToEnum(const wstring& cipher)
	{
		if (cipher == L"AES_CBC") {
			return AES_CBC;
		}
		else // || if (cipher == L"BF_CBC")
		{
			return BF_CBC;
		}
	};
}
#endif // !_H_CRYPT_CTX_