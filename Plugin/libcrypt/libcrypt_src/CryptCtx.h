#ifndef _H_CRYPT_CTX_
#define _H_CRYPT_CTX_

#include <string>
#include <cstdint>
#include <unordered_map>
#include <openssl/evp.h>
#include "CryptUtils.h"
#include "CryptInfo.h"

namespace crypt
{
	using std::wstring;

	/** Call this to initialize the library once. Initializes openssl. */
	void	initLibcrypt	();
	void	unloadLibcrypt	();

	/*****************************************************************/
	/*************************** CryptCtx ****************************/
	/*****************************************************************/
	class CryptCtx
	{
	public:
		typedef std::wstring ucs;
		static CipherEnum			CipherStrToEnum		(const wstring& cipher);
		/**
		*	Creates and stores a crypt-ctx and returns its handle. This handle should
		*	be returned to Javascript for use later with the API. The $ parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param $. passwd. Gets zeroe'd out if the call is successful.
		* @param cipher. The cipher to use for en/decryption.
		* @param key_len. The length of the key to be generated for en/decryption.
		*/
		static void					Create				(const ucs& handle,
														 Buf<char>& $,
														 CipherEnum cipher = CIPHER_BF_CBC,
														 unsigned int key_len = DEFAULT_KEY_LEN);
		/**
		*	Creates and stores a crypt-ctx and returns its handle. This handle should
		*	be returned to Javascript for use later with the API. The $ parameter is
		*   zeroed out if the call is successful. Throws exceptions in case of errors.
		* @param $. passwd. Gets zeroe'd out if the call is successful.
		* @param cryptInfo. cryptInfo bytes read from an encrypted AB. Should've been
		*	generated by serializeInfo().
		*/
		static void					Load				(const ucs& handle,
														 Buf<char>& $,
														 const Buf<uint8_t>& cryptInfo);
		static const CryptCtx&		Get					(const ucs& handle);
		static const CryptCtx*		GetP				(const ucs& handle);
		static bool					Exists				(const ucs& handle);
		static void					Destroy				(const ucs& handle);

		const CryptInfo&			GetInfo				() const {return m_info;}
		void						serializeInfo		(BufHeap<uint8_t>& outBuf) const;
		void						Encrypt				(const Buf<uint8_t>& in,
														 ByteBuf& out) const;
		void						Decrypt				(ByteBuf&& in, ByteBuf& out) const;
		bool						operator==			(const CryptCtx& other) const 
			{ return m_randKey == other.m_randKey; }

	protected:
									CryptCtx			(CipherEnum cipher,
														 unsigned int keyLen);
									CryptCtx			(const Buf<uint8_t>& cryptInfo);
		virtual						~CryptCtx			() {zero();}
		virtual void				zero				();

	private:
									CryptCtx			(const CryptCtx&);// not to be defined
		CryptCtx&					operator=			(const CryptCtx&);// not to be defined
		//static unsigned int			MakeHandle			() {return ++s_lastHandle;}
		void						EncryptImpl			(const Buf<uint8_t>& in,
														 ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		void						DecryptImpl			(ByteBuf&& in,
														 ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		size_t						DecryptOne			(CipherBlob& in, ByteBuf& out,
														 const uint8_t* pKey = NULL) const;
		//typedef std::unordered_map<unsigned int, CryptCtx*> map;
		typedef std::unordered_map<ucs, CryptCtx*> map;
		static map					s_ctxMap;
		//static unsigned int			s_lastHandle;

		/** Object variables */
		Array<uint8_t, SCRYPT_DK_SIZE> m_dk;
		ByteBuf						m_randKey;
		CryptInfo					m_info;
	};

	inline void
	CryptCtx::Decrypt(ByteBuf&& in, ByteBuf& out) const
	{
		DecryptImpl(std::forward<ByteBuf>(in), out, m_randKey);
	}

	inline void
	CryptCtx::Encrypt(const Buf<uint8_t>& in, ByteBuf& out) const
	{
		EncryptImpl(in, out, m_randKey);
	}

	inline CipherEnum
	CryptCtx::CipherStrToEnum(const wstring& cipher)
	{
		if (cipher == L"CIPHER_AES_CBC") {
			return CIPHER_AES_CBC;
		}
		else // || if (cipher == L"CIPHER_BF_CBC")
		{
			return CIPHER_BF_CBC;
		}
	};
}
#endif // !_H_CRYPT_CTX_